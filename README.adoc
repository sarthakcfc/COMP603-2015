= Compiler Design

== May 13: Chomsky, Derivatives, Compilers and Visitors, oh my!

=== Chomsky again

The Chomsky hierarchy is a containment hierarchy of languages.
What distinguishes one language category from another is
restrictions placed on grammars or the underlying automaton.

image:http://lawrancej.github.io/COMP603-2015/scribbles/chomsky-hierarchy.png[Chomsky hierarchy]

[cols="3", options="header"]
|===

|Language category
|Description
|Equivalent automaton

|*Recursively-enumerable*
|Arbitrary sequences of terminals and non-terminals can derive arbitrary sequences of terminals and nonterminals.
|Finite automaton with infinite tape and read/write head (Turing machine)

|*Context-sensitive*
|A nonterminal flanked on either side by terminals and nonterminals (the context) derives a nonempty string of terminals or nonterminals surrounded by the same context.
|Finite automaton with finite tape and read/write head (Linearly-bounded Turing machine)

|*Context-free*
|Nonterminals derive sequences of terminals and nonterminals.
|Pushdown automaton (finite state machine with a stack)

|*Regular*
|A nonterminal can derive a terminal followed by a nonterminal or nothing at all.
|Finite state machine

|===

=== Derivatives

http://matt.might.net/articles/parsing-with-derivatives/[A discussion of derivatives and parsing with them].

=== Compilers

Compilers consist of these 'phases':

[cols="4", options="header"]
|===
|Phase
|Description
|Input
|Output

|*Scan / Tokenize / Lexical analysis*
|Split source code into small chunks (tokens) such as identifiers, reserved words, literals, operators, etc.
|Source code
|Token stream

|*Parse*
|Check the syntax of the source code
|Token stream
|Parse tree

|*Translate*
|Translate low level syntax into high-level abstract syntax tree
|Parse tree
|Abstract syntax tree, symbol table

|*Optimize*
|Improve performance or structure
|Abstract syntax tree, symbol table
|Abstract synatx tree, symbol table

|*Generate code*
|Traverse the AST to generate code.
|Abstract syntax tree, symbol table
|Target code

|===

The *front-end* of a compiler consists of scanning and parsing;
the *back-end* consists of translation, optimization and code generation.

=== Visitors

They visit, silly!

=== Challenge

Challenge: What's the parse tree for `int a = 5;`?

== May 11: Regexes and Grammars

Cheat at http://puzzles.usatoday.com/[today's crossword puzzle],
the easy way with regexes!

----
cd ~/COMP603-2015
git pull upstream master
grep -E "^regex-goes-here$" american-english.txt
----

A *regular expression* (regex) defines a language with these primitives and operators.

[options="header"]
|===
|Name |Notation |Meaning

|*Primitives*
|
|Regular expression building block.

|*Empty Set*
|{}
|Reject everything.

|*Empty String*
|+""+
|Match the empty string.

|*Symbol*
|`a`
|Match a single character.

|*Operator*
|
|Make a new regex from existing regexes.

|*Sequence*
|`ab`
|Match regex `a` followed by regex `b`.

|*Alternation*
|`a\|b`
|Match regex `a` or match regex `b`, but not both.

|*Kleene Star*
|`a*`
|Match regex `a` zero or more times {+""+,`a`,`aa`,`aaa`,...}

|===

The primitives and operators above are *complete*:
we can define other regular expression operators in terms of them.
For example, `a?` optionally matches `a`; `a? = a|""`.
Another example: `a+` matches `a` 1 or more times; `a+ = a*a`.

Trivially, finite languages are regular:

----
finite language:  {"hello","cruel","world"}
equivalent regex: hello|cruel|world
----

Since regular languages can be infinite, they encompass the finite languages.

----
.* (Matches everything)
----

Regular languages can't express everything; 
for example, they cannot check matching brackets in the general case.
Hence, the other classes of languages.

The Chomsky hierarchy is a containment hierarchy of languages.
What distinguishes one language category from another is
restrictions placed on grammars or the underlying automaton.

image:http://lawrancej.github.io/COMP603-2015/scribbles/chomsky-hierarchy.png[Chomsky hierarchy]

A *grammar* consists of a finite set of nonterminals (variables),
a starting nonterminal, terminals (literals, words or symbols),
and productions (rules) that map among terminals and nonterminals.
Grammars define languages: they generate the set of strings in the language
and test membership of a string in the language.

The example grammar below defines a small subset of English, with an example sentence.
The example grammar is context-free because the left side of each arrow is a nonterminal.

image:http://lawrancej.github.io/COMP603-2015/scribbles/example-grammar.png[Example grammar and sentence]

== May 8: Introduction

NOTE: Please read http://www.ethoberon.ethz.ch/WirthPubl/CBEAll.pdf[Chapters 1, 2 and 3 (Pages 6-16)]
or Chapters 1, 2 and 3 of the Crafting a Compiler textbook by next week.
If this is overwhelming, read the first sentence of each paragraph,
then skip subsequent sentences if it made sense, otherwise read on.
https://github.com/vhf/free-programming-books/blob/master/free-programming-books.md#compiler-design[See this list for other free books].

=== What is the difference between a set, a bag, and a sequence?

These are all collections.

A *set* is unordered and has no duplicates (no repeated values).

----
{ "hello", "world" } == { "world", "hello" }
----

A *bag* is unordered and allows duplicates (repeated values).

----
{ "buffalo", "my", "buffalo" } == { "my", "buffalo", "buffalo" }
----

A *sequence* is ordered and allows duplicates.

----
[ "hello", "cruel", "world" ] != [ "cruel", "world", "hello" ]
----

An *ordered set* is ordered and has no duplicates.

To summarize:

image:http://lawrancej.github.io/COMP603-2015/scribbles/collections.png[Kinds of collections]

=== What is a language in terms of sets and sequences?

English subset

----
{
    "This is a sentence in English.",
    "This is another sentence in English."
}
----

Espanol subseto?

----
{
    "Yo quiero Taco Bell",
    "Donde esta el bano?"
}
----

An *alphabet* is a set of symbols (e.g., `char`).
A *string* is a sequence of symbols chosen from some alphabet.

*Languages* are (possibly infinite) sets of strings.
A *grammar* constructs a language; *regular expressions* construct *regular* languages.

=== What is a compiler? Name some.

A *compiler* transforms source language into a target language.

javac, gcc, clang, etc.

=== What is an interpreter? How does that differ from a compiler?

An *interpreter* accepts code and runtime data and runs with it.
We're not generating code.

== May 7: Git setup and prequiz

=== Install Git and frontends

[[install-git]]
Windows:: http://sourceforge.net/projects/gitextensions/[Install Git Extensions]
+
NOTE: Install MsysGit, Install KDiff, and *choose OpenSSH* (not PuTTY); otherwise,
stick to the default settings.
+
image:http://lawrancej.github.io/starterupper/images/what2install.png[Install MsysGit and KDiff]
image:http://lawrancej.github.io/starterupper/images/openssh.png[Choose OpenSSH]

Mac OS X:: http://rowanj.github.io/gitx/[Install GitX-dev], then https://developer.apple.com/xcode/downloads/[Install XCode developer tools] which ships with git (recommended) or http://git-scm.com/download/mac[install git from here].

Linux:: http://git-scm.com/download/linux[Install git] using your package manager.
http://sourceforge.net/projects/qgit/[QGit, a git frontend] may also be available for your distribution.
+
NOTE: Don't forget to use +sudo+ with your package manager.

=== Run starterupper

Starterupper sets up git and project hosting for this class;
it is safe to run even if you already have git and SSH keys set up on your machine.

Open Git Bash (Windows) or Terminal (Linux, Mac OS X) and paste in the command below.
Press `Insert` to paste in Git Bash.

----
curl https://raw.githubusercontent.com/lawrancej/COMP603-2015/master/main.sh | bash
----

=== Complete the prequiz

Open up `prequiz.adoc` in your favorite text editor (it is in your local git repository).

WARNING: Do not use Notepad or Word.
Use a real text editor. Suggestions:
http://notepad-plus-plus.org/download/v6.7.7.html[Notepad++] (Windows),
https://atom.io/[Atom],
or http://www.sublimetext.com/[Sublime].

Then, save your changes and submit your work to your repository.

----
cd ~/COMP603-2015
# The easy way
git gui &
# The leet way
git add .
git commit -m "Finished prequiz"
git push -u --all origin
----

== May 6: Introductions

Welcome to Compiler Design!

Icebreaker:

* What is your name?
* Why is Computer Science your major?
* Tell us something nobody else in the room knows about you.
